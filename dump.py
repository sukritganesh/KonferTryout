{"cells":[{"cell_type":"code","execution_count":2,"metadata":{"executionInfo":{"elapsed":12751,"status":"ok","timestamp":1668896340289,"user":{"displayName":"Sukrit Ganesh","userId":"09882607507987906814"},"user_tz":480},"id":"zLTaybv5dNHG"},"outputs":[],"source":["# from pgmpy.inference import VariableElimination\n","# from pgmpy.models import BayesianNetwork\n","import math\n","import scipy as sp\n","import numpy as np\n","import pandas as pd\n","import networkx as nx\n","import matplotlib.pyplot as plt\n","import pandas as pd\n","import numpy as np\n","import matplotlib.pyplot as plt\n","from matplotlib.ticker import PercentFormatter\n","import time\n","from statsmodels.tsa.stattools import grangercausalitytests\n","\n","import os,sys\n","from datetime import datetime\n","import warnings\n","warnings.filterwarnings('ignore')\n","\n","from numpy import array\n","import keras\n","from keras.models import Sequential\n","from keras.layers import LSTM\n","from keras.layers import Dense, Dropout\n","import tensorflow as tf\n","import joblib\n","from joblib import Parallel, delayed\n","from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_percentage_error\n","from keras.callbacks import EarlyStopping\n","from sklearn.preprocessing import MinMaxScaler\n","import multiprocessing\n","import seaborn as sns\n","import traceback\n","import glob\n","#import bnlearn as bn\n","from sklearn.model_selection import train_test_split\n","from sklearn.neighbors import KNeighborsRegressor\n","from collections import OrderedDict\n","from sklearn.model_selection import LeaveOneOut\n","from tqdm import tqdm"]},{"cell_type":"code","execution_count":3,"metadata":{"executionInfo":{"elapsed":923,"status":"ok","timestamp":1668896351158,"user":{"displayName":"Sukrit Ganesh","userId":"09882607507987906814"},"user_tz":480},"id":"nawJQxIGklhI"},"outputs":[],"source":["class KnnModelTrain:\n","    '''\n","    Attributes\n","    ----------------------------------------------------------------------------\n","    input_path : Pandas DataFrame\n","        -> Path of the full csv file\n","    akm_to_model_path : str\n","        -> Path of the akm_to_model for KNN csv file\n","    logfile_path\n","        -> Path where logfile to be stored\n","    model_path\n","        -> Path where trained KNN models/jsons to be stored\n","    independent_features\n","        -> List of independent features for training\n","    target_feature\n","        -> Target feature name\n","\n","    Methods\n","    ----------------------------------------------------------------------------\n","    readcsv(file)\n","        -> It reads csv and return dataframe with sorted values by AKM and REPORT_DATE\n","\n","    getakmdata(fulldf,ad,kw,mt)\n","        -> It returns dataframe for the given akm values from the fulldf\n","\n","    isEnoughData(df,columns)\n","        -> It return True/False based on distinct value count of the target feature\n","    \n","    computeSMAPENoExp(act,pred)\n","        -> It returns smape value from the from the actual and predicted values\n","\n","    buildLaggedData(akm,akmdf,features,target, maxlag)\n","        -> It returns dictionary of LagToData and LagToFeatures \n","        LagToData ->  It will have Lag as key and corresponding dataframe as value\n","        LagToFeatures ->It will have Lag as key and corresponding feature list as value\n","\n","    trainModelAndLOOCVTest(akm,LagToData,LagToFeatures,target,objective,successfile)\n","        -> It returns Best lag dataframe, Best lag value and Best lag features list\n","        \n","    pyplotscatter(akm,target,actual,predicted,setrange)\n","        -> It will plot scattered plot of actual and predicted values with regression line\n","\n","    get_stats(df,feature)\n","        -> It will return  dictionary of 'min','max','mean' and 'std' value of the target feature\n","\n","    serialize_model(model,root_path,AD_GROUP_ID,KEYWORD_ID,MATCH_TYPE)\n","        -> It will serialize model for the given AKM combination and store it at root_path\n","\n","    serialize_akm_metadata(args)\n","        -> It will store akm metadata as json in binary format.\n","\n","    finalKNNModelTrainAndTest(akm,bestLag,bestLagData,bestFeatures,target,testsize,successfile)\n","        -> it will train KNN model on 80% data and test on 20% data and returns dictionary of \n","           'bestLag' ,'smapedatalength', 'skippedcnt', 'testsmape'\n","\n","    finalKNNModel(bestLagData,bestFeatures,target)\n","        -> It will return trained KNN model object on 100% data\n","\n","    trainModels(input_path,akm_to_model_path,logfile_path,model_path)\n","        -> It will train models for each AKM combinatiion from the akm_to_model file and store it at given path\n","\n","    '''\n","    def __init__(self,input_path,akm_to_model_path,logfile_path,model_path,independent_features,target_feature,max_lag,knnweight):\n","        self.input_path = input_path\n","        self.akm_to_model_path = akm_to_model_path\n","        self.logfile_path = logfile_path\n","        self.model_path = model_path\n","        self.independent_features = independent_features #independent features\n","        self.target_feature = target_feature\n","        self.max_lag = max_lag\n","        self.todays_date = datetime.now()\n","        self.knnweight = knnweight\n","        \n","    def readcsv(self,file):\n","        '''\n","        Args:\n","            file -> Input file path to read csv file\n","        Returns:\n","            It reads csv and return dataframe with sorted values by AKM and REPORT_DATE\n","        '''\n","        fullakmdf = pd.read_csv(file,parse_dates=['REPORT_DATE'])\n","        fullakmdf.sort_values(by=['AD_GROUP_ID','KEYWORD_ID','MATCH_TYPE','REPORT_DATE'])\n","        return fullakmdf\n","\n","    def getakmdata(self,fulldf,ad,kw,mt):\n","        '''\n","        Args:\n","            fulldf -> full dataframe with all akms\n","            ad -> AD_GROUP_ID value\n","            kw -> KEYWORD_ID value\n","            mt -> MATCH_TYPE value\n","        Returns:\n","            Return dataframe for the given akm combination\n","        '''\n","        akmdf = fulldf.loc[(fulldf['AD_GROUP_ID'] == ad) & (fulldf['KEYWORD_ID'] == kw) & (fulldf['MATCH_TYPE'] == mt)].reset_index(drop=True)\n","        akmdf = akmdf.sort_values(by=['REPORT_DATE']).reset_index(drop=True)\n","        return akmdf\n","\n","    def isEnoughData(self,df,columns):\n","        '''\n","        Args:\n","            df -> input dataframe\n","            columns -> target feature name(list)\n","        Returns:\n","            It return True/False based on distinct value count of the target feature\n","        '''\n","        for col in columns:\n","            distcnt = np.count_nonzero(df[col], axis=0)\n","            if (distcnt < 10):\n","                return False\n","            # sd = df[col].std()\n","        return True\n","\n","    def computeSMAPENoExp(self,act,pred):\n","        '''\n","        Args :\n","            act -> array/series/list of actual values \n","            pred -> array/series/list of predicted values\n","        Returns :\n","            It return symetric mean absolute percentage error\n","\n","        Assumption: actuals and predictions are not logarithms\n","        '''\n","         \n","        #Assumption: actuals and predictions are not logarithms\n","        smape = 0\n","        skippedcnt = 0\n","        for a,p in zip(act,pred):\n","            den = abs(a) + abs(p)\n","            if (den > 0):\n","                num = 2*abs(p-a)\n","            else:\n","                den = 1\n","                num = 2*abs(p-a)\n","                skippedcnt += 1\n","                \n","            smape += (num/den)\n","        \n","        smape = (100*smape)/len(act)\n","        smapedatalength = len(act)\n","                            \n","        return smapedatalength, skippedcnt, round(smape,2)\n","\n","    def buildLaggedData(self,akm,akmdf,features,target, maxlag):\n","        '''\n","        Args:\n","            akm -> akm string \n","            akmdf -> akm dataframe\n","            features -> independent feature list\n","            target -> target feature name\n","            maxlag -> maxlag value\n","        Returns:\n","            -> It returns dictionary of LagToData and LagToFeatures \n","            LagToData ->  It will have Lag as key and corresponding dataframe as value\n","            LagToFeatures ->It will have Lag as key and corresponding feature list as value\n","        '''\n","        LagToData = OrderedDict()\n","        LagToFeatures = OrderedDict()\n","        \n","        for lag in range(1,maxlag+1,1):\n","            if (lag == 1):\n","                #for first lag, create new dataframe and add target column data\n","                df = pd.DataFrame()\n","                df[target] = akmdf[target]\n","                newfeatures = []\n","            else:\n","                #for other lags lag, start with the previous lag's data\n","                df = LagToData[lag-1].copy(deep=True)\n","                newfeatures = [x for x in LagToFeatures[lag-1]]\n","            \n","            #Create lagged features for the given features\n","            for col in features:\n","                newcol = col+'_lag'+str(lag)\n","                df[newcol] = akmdf[col].shift(lag)\n","                newfeatures.append(newcol)\n","            \n","            #create lagged features for the target\n","            newcol = target+'_lag'+str(lag)\n","            df[newcol] = akmdf[target].shift(lag)\n","            newfeatures.append(newcol)\n","            \n","            #delete first row because it has missing features from lagging.\n","            #This is cumulative for the new DFs for new lags\n","            df = df.iloc[1:,:]\n","            \n","            #Add data and feature names to the dictionary\n","            LagToData[lag] = df\n","            LagToFeatures[lag] = newfeatures\n","            \n","        return LagToData, LagToFeatures\n","\n","    def trainModelAndLOOCVTest(self,akm,LagToData,LagToFeatures,target,objective,successfile):\n","        '''\n","        Args:\n","            akm -> akm string\n","            LagToData -> Dictionary with Lag as key and corresponding dataframe as value\n","            LagToFeatures -> Dictionary with Lag as key and corresponding Lag features as value\n","            target -> target feature name\n","            objective -> smape or r2\n","            successfile -> logfile\n","        Returns:\n","            It returns Best lag dataframe, Best lag value and Best lag features list\n","        '''\n","        #while strictly not necessary, assuming ordered dictionary for aesthetic reasons\n","        bestsmape = 1000000\n","        bestlag = 0\n","        bestsmapeskippedcnt = 0\n","        bestsmapedatalength = 0\n","        bestr2 = -1000000\n","        \n","        if (objective == 'smape'):\n","            for lag, df in LagToData.items():\n","                if (len(df.index) < 30):\n","                    print('Skipping modeling of lag = '+ str(lag) + 'for ' + akm + ' because numrows < 30')\n","                    continue\n","\n","                features = LagToFeatures[lag]\n","\n","                X = df[features].to_numpy()\n","                y = df[target].to_numpy()\n","\n","                loo = LeaveOneOut()\n","                act = []\n","                pred = []\n","                for train_index, test_index in loo.split(X):\n","                    X_train, X_test = X[train_index], X[test_index]\n","                    y_train, y_test = y[train_index], y[test_index]            \n","                    knn = KNeighborsRegressor(n_neighbors=5,weights=self.knnweight)\n","                    knn.fit(X_train,y_train)\n","                    y_test_pred = knn.predict(X_test)\n","                    #Assumption: LOOCV ==> only one element in the test data\n","                    #remember log(z+1) has been done on target\n","                    pred.append(math.exp(y_test_pred[0])-1)\n","                    act.append(math.exp(y_test[0])-1)\n","\n","                smapedatalength, skippedcnt, smape = self.computeSMAPENoExp(act,pred)\n","                r2 = round(r2_score(act,pred),2)\n","\n","                #Using SMAPE as the the criterion which must be minimized\n","                if (smape < bestsmape):\n","                    bestsmape = smape\n","                    bestlag = lag\n","                    bestsmapeskippedcnt = skippedcnt\n","                    bestsmapedatalength = smapedatalength\n","                    bestr2 = r2\n","\n","            bestlagdatalength = len(LagToData[bestlag].index)\n","            lag1datalength = len(LagToData[1].index)\n","            print('AKM\\ttarget\\tbestSMAPE\\tr2\\tskippedcnt\\tdatalength\\tlag = '+akm+'\\t'+target+'\\t'+str(bestsmape)+'\\t'+str(bestr2)+'\\t'+str(bestsmapeskippedcnt)+'\\t'+str(smapedatalength)+'\\t'+str(bestlag))\n","            successfile.write('AKM\\ttarget\\tbestSMAPE\\tr2\\tskippedcnt\\tdatalength\\tlag = '+akm+'\\t'+target+'\\t'+str(bestsmape)+'\\t'+str(bestr2)+'\\t'+str(bestsmapeskippedcnt)+'\\t'+str(smapedatalength)+'\\t'+str(bestlag)+'\\n')\n","            successfile.flush()\n","            return LagToData[bestlag], bestlag, LagToFeatures[bestlag]\n","        \n","        #objective is r2\n","        else:\n","            for lag, df in LagToData.items():\n","                if (len(df.index) < 30):\n","                    print('Skipping modeling of lag = '+ str(lag) + 'for ' + akm + ' because numrows < 30')\n","                    continue\n","\n","                features = LagToFeatures[lag]\n","\n","                X = df[features].to_numpy()\n","                y = df[target].to_numpy()\n","\n","                loo = LeaveOneOut()\n","                act = []\n","                pred = []\n","                for train_index, test_index in loo.split(X):\n","                    X_train, X_test = X[train_index], X[test_index]\n","                    y_train, y_test = y[train_index], y[test_index]            \n","                    knn = KNeighborsRegressor(n_neighbors=5,weights=self.knnweight)\n","                    knn.fit(X_train,y_train)\n","                    y_test_pred = knn.predict(X_test)\n","                    #Assumption: LOOCV ==> only one element in the test data\n","                    #remember log(z+1) has been done on target\n","                    pred.append(math.exp(y_test_pred[0])-1)\n","                    act.append(math.exp(y_test[0])-1)\n","\n","                smapedatalength, skippedcnt, smape = self.computeSMAPENoExp(act,pred)\n","                r2 = round(r2_score(act,pred),2)\n","\n","                #Using r2 as the the criterion which must be maximized\n","                if (r2 > bestr2):\n","                    bestsmape = smape\n","                    bestlag = lag\n","                    bestsmapeskippedcnt = skippedcnt\n","                    bestsmapedatalength = smapedatalength\n","                    bestr2 = r2\n","\n","            bestlagdatalength = len(LagToData[bestlag].index)\n","            lag1datalength = len(LagToData[1].index)\n","            \n","            print('AKM\\ttarget\\tSMAPE\\tbestr2\\tskippedcnt\\tdatalength\\tlag = '+akm+'\\t'+target+'\\t'+str(bestsmape)+'\\t'+str(bestr2)+'\\t'+str(bestsmapeskippedcnt)+'\\t'+str(smapedatalength)+'\\t'+str(bestlag))\n","            successfile.write('AKM\\ttarget\\tSMAPE\\tbestr2\\tskippedcnt\\tdatalength\\tlag = '+akm+'\\t'+target+'\\t'+str(bestsmape)+'\\t'+str(bestr2)+'\\t'+str(bestsmapeskippedcnt)+'\\t'+str(smapedatalength)+'\\t'+str(bestlag)+'\\n')\n","            successfile.flush()\n","            return LagToData[bestlag], bestlag, LagToFeatures[bestlag]\n","\n","    def pyplotscatter(self,akm,target,actual,predicted,setrange):\n","        '''\n","        Args:\n","            akm -> akm string \n","            target -> target feature name\n","            actual -> list/array ofactual values\n","            predicted -> list/array of predicted values\n","            setrange ->\n","        Returns:\n","            It will plot scattered plot of actual and predicted values with regression line\n","        '''\n","        x = actual\n","        y = predicted\n","        title = akm+'::'+target+'::test actual .vs predicted'+'::target actl min::'+str(round(min(x),2))+'::max::'+str(round(max(x),2))\n","        subtitle = akm+'::'+target+'::test actual .vs predicted'+'::target pred min::'+str(round(min(y),2))+'::max::'+str(round(max(y),2))\n","        plt.figure(figsize=(5,5))\n","        plt.title(title)\n","        plt.suptitle(subtitle)\n","        plt.scatter(x,y)\n","        plt.xlabel('actual')\n","        plt.ylabel('predicted')\n","        \n","        #calculate equation for trendline and add it to the plot\n","        try:\n","            z = np.polyfit(x, y, 1)\n","            p = np.poly1d(z)\n","            r_squared = r2_score(x, y)\n","            plt.plot(x, p(x), label=(\"$R^2$=%.6f\"%(r_squared)))\n","            plt.legend()\n","        except:\n","            pass\n","\n","        if (setrange):\n","            mini = min(min(x),min(y))\n","            maxi = max(max(x),max(y))\n","            plt.xlim(mini,maxi)\n","            plt.ylim(mini,maxi)\n","\n","        plt.show()\n","        time.sleep(0.05)\n","\n","    def get_stats(self,df,feature):\n","        '''\n","        Args :\n","            df -> input dataframe\n","            feature -> feature name for which statistics to be returned\n","        Returns :\n","            It returns min, max, mean, std and max_roc for the given feature from the training data\n","        '''\n","        max_val = round(df[feature].max(),2)   # get maximum value for the given feature\n","        mean_val = round(df[feature].mean(),2) # get mean value for the given feature\n","        std_val = round(df[feature].std(),2)   # get standard deviation for the given feature\n","        #max_roc = round(df[f'{feature}_DELTA(%)'].max(),2)  # get maximum roc from the delta values\n","\n","        non_zero_indicies = df[feature].to_numpy().nonzero()  # find non zero value indicies for given feature\n","        non_zero_values = df[feature].iloc[non_zero_indicies] # get the non zero value array\n","        min_val = min(non_zero_values)                        # get the minimum value from the non zero values\n"," \n","        return {'min':min_val,\n","                'max':max_val,\n","                'mean':mean_val,\n","                'std':std_val}\n","                #'max_roc':max_roc}\n","\n","    def serialize_model(self,model,root_path,AD_GROUP_ID,KEYWORD_ID,MATCH_TYPE):\n","        '''\n","        Args:\n","            model -> trained model object\n","            root_path -> path to store model\n","            AD_GROUP_ID -> value of AD_GROUP_ID\n","            KEYWORD_ID -> value of KEYWORD_ID\n","            MATCH_TYPE -> value of MATCH_TYPE\n","        Returns:\n","            It will serialize model for the given AKM combination and store it at root_path\n","        '''\n","        # year\n","        year = self.todays_date.strftime(\"%Y\")\n","        # Month\n","        month = self.todays_date.strftime(\"%m\")\n","        # Day\n","        day = self.todays_date.strftime(\"%d\")\n","        # join string with current year, month and day\n","        year_month_day =  str(year) + str(month) + str(day)\n","        \n","        # model name as a string of year_month_day_AD_GROUP_ID_KEYWORD_ID_MATCH_TYPE_{target_feature}Model\n","        model_name = '_'.join([year_month_day,\n","                               str(int(AD_GROUP_ID)),\n","                               str(int(KEYWORD_ID)),\n","                               str(MATCH_TYPE),\n","                               f'{self.target_feature}',\n","                               'KNNModel'])\n","        \n","        full_path = os.path.join(root_path,model_name) + '.pickle' # full model path with pickle format\n","        os.makedirs(root_path,exist_ok=True) # create directory if it does not exist\n","        joblib.dump(model,full_path) # dump model\n","        print(f'\\n ********** KNN model saved at {full_path} **********')\n","\n","    def serialize_akm_metadata(self,\n","                               df_akm,\n","                               model_root_path,\n","                               AD_GROUP_ID,\n","                               KEYWORD_ID,\n","                               MATCH_TYPE,\n","                               independent_features,\n","                               target_feature,\n","                               best_lag,\n","                               testsmape,\n","                               testdata_length,\n","                               skipped_smape_cnt,\n","                               date_range,\n","                               at_least_one_col_zero,\n","                               at_least_one_col_non_zero,\n","                               all_col_zero,\n","                               total_records,\n","                               total_records_best_lag_df,\n","                               best_lag_train_df_records,\n","                               isEnoughData_flag):\n","        '''\n","        Returns :\n","            It will serialize AKM values along with the stats of model as a json as binary format and store at a given location.\n","        '''\n","        \n","        # year\n","        year = self.todays_date.strftime(\"%Y\")\n","        # Month\n","        month = self.todays_date.strftime(\"%m\")\n","        # Day\n","        day = self.todays_date.strftime(\"%d\")\n","\n","        year_month_day =  str(year) + str(month) + str(day)\n","\n","        model_name = '_'.join([year_month_day, \n","                               str(int(AD_GROUP_ID)),\n","                               str(int(KEYWORD_ID)),\n","                               str(MATCH_TYPE),\n","                               f'{self.target_feature}',\n","                               'KNNModel'])\n","        \n","        model_stats = self.get_stats(df_akm,self.target_feature)\n","\n","        # create akm json to store at specified location\n","        akm_dict = {'AD_GROUP_ID' : int(AD_GROUP_ID),\n","                    'KEYWORD_ID' : int(KEYWORD_ID),\n","                    'MATCH_TYPE' : str(MATCH_TYPE),\n","                    'MODEL_VERSION' : str(self.todays_date),\n","                    'MODEL' : {\n","                        'NAME' : model_name,\n","                        'INDEPENDENT_FEATURES' : independent_features,\n","                        'TARGET_FEATURE' : target_feature,\n","                        'STATS' : {\n","                            'BEST_LAG' : best_lag,\n","                            'TEST_SMAPE' : testsmape,\n","                            'TEST_DATA_LENGTH' : testdata_length,\n","                            'SKIPPED_SMAPE_COUNT' : skipped_smape_cnt,\n","                            'DATE_RANGE' : date_range,\n","                            'AT_LEAST_ONE_COL_ZERO' : at_least_one_col_zero,\n","                            'AT_LEAST_ONE_COL_NON_ZERO' : at_least_one_col_non_zero,\n","                            'ALL_COL_ZERO' : all_col_zero,\n","                            'TOTAL_RECORDS' : total_records,\n","                            'TOTAL_RECORDS_BEST_LAG_DF' : total_records_best_lag_df,\n","                            'BEST_LAG_TRAIN_DF_RECORDS' : best_lag_train_df_records,\n","                            'IS_ENOUGH_DATA' : isEnoughData_flag,\n","                            f'{self.target_feature}_MIN' : model_stats['min'],\n","                            f'{self.target_feature}_MAX' : model_stats['max'],\n","                            f'{self.target_feature}_MEAN' : model_stats['mean'],\n","                            f'{self.target_feature}_SD' : model_stats['std']\n","                        }   \n","                    }\n","                }\n","                \n","        full_path = os.path.join(model_root_path,model_name)\n","        # dump json at specified location\n","        joblib.dump(akm_dict,filename=full_path+'.json')\n","        print('*'*10,'AKM metadata Dictionary saved at {}'.format(full_path+'.json'),'*'*10,'\\n')\n","        return 'AKM metadata Dictionary saved at {}'.format(model_root_path)\n","\n","    def finalKNNModelTrainAndTest(self,akm,bestLag,bestLagData,bestFeatures,target,testsize,successfile):\n","        '''\n","        Args:\n","            akm -> akm string\n","            bestLag -> bestLag value\n","            bestLagData -> bestLag dataframe\n","            bestFeatures -> bestLag features\n","            target -> target feature name\n","            testsize -> test size (0.20)\n","            successfile -> logfile\n","        Returns:\n","            it will train KNN model on 80% data and test on 20% data and returns dictionary of \n","           'bestLag' ,'smapedatalength', 'skippedcnt', 'testsmape'\n","        '''\n","        X = bestLagData[bestFeatures].to_numpy()\n","        y = bestLagData[target].to_numpy()\n","\n","        # train test split \n","        X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=testsize,random_state=0)\n","        knn = KNeighborsRegressor(n_neighbors=5,weights=self.knnweight)\n","        knn.fit(X_train,y_train)\n","        y_test_pred = knn.predict(X_test)\n","\n","        # remember log(z+1) xfrm has been used on target\n","        ytestreg = np.exp(y_test)-1\n","        ypredreg = np.exp(y_test_pred)-1\n","\n","        smapedatalength, skippedcnt, testsmape = self.computeSMAPENoExp(ytestreg.tolist(),ypredreg.tolist())\n","        testr2 = round(r2_score(ytestreg, ypredreg),2)\n","        print('AKM\\ttarget\\ttestSMAPE\\tr2\\tskippedcnt\\tdatalength\\tLag = '+akm+'\\t'+target+'\\t'+str(testsmape)+'\\t'+str(testr2)+'\\t'+str(skippedcnt)+'\\t'+str(smapedatalength)+'\\t'+str(bestLag))\n","        successfile.write('AKM\\ttarget\\ttestSMAPE\\tr2\\tskippedcnt\\tdatalength\\tLag = '+akm+'\\t'+target+'\\t'+str(testsmape)+'\\t'+str(testr2)+'\\t'+str(skippedcnt)+'\\t'+str(smapedatalength)+'\\t'+str(bestLag)+'\\n')\n","        successfile.flush()\n","        self.pyplotscatter(akm,target,ytestreg,ypredreg,True)\n","        return {'bestLag' : bestLag, 'smapedatalength' : smapedatalength, 'skippedcnt' : skippedcnt, 'testsmape' : testsmape, 'testr2' : testr2}\n","\n","    def finalKNNModel(self,bestLagData,bestFeatures,target):\n","        '''\n","        Args:\n","            bestLagData -> bestLag dataframe\n","            bestFeatures -> bestLag feature list\n","            target -> target feature name\n","        Returns:\n","            It will train KNN model on 100% data(bestLag Data)\n","        '''\n","        X = bestLagData[bestFeatures].to_numpy()\n","        y = bestLagData[target].to_numpy()\n","        knn = KNeighborsRegressor(n_neighbors=5,weights=self.knnweight)\n","        knn.fit(X,y)\n","        return knn\n","\n","    def trainModels(self,input_path,akm_to_model_path,logfile_path,model_path):\n","        '''\n","        Args:\n","            input_path -> input path with all akms data \n","            akm_to_model_path -> Csv of the AD_GROUP_ID, KEYWORD_ID and MATCH_TYPE to train KNN models only\n","            logfile_path -> Path to store logfile\n","            model_path -> Path to store trained models\n","        Returns:\n","            It will train and store models/jsons for each akm and return statistics dataframe\n","        '''\n","        fulldf = self.readcsv(input_path) # fulldf means selected akm joined file with original file on 19th october\n","        akms2model = pd.read_csv(akm_to_model_path)\n","\n","        # akms2model = fulldf.copy()\n","        # akms2model = akms2model.groupby(['AD_GROUP_ID','KEYWORD_ID','MATCH_TYPE']).size().reset_index().rename(columns={0:'count'})\n","        \n","        print('Number of AKMs to model = '+ str(akms2model.shape[0]))\n","        count = 0\n","        \n","        os.makedirs(logfile_path,exist_ok=True) # create directory if it does not exist\n","        logfile_full_path = os.path.join(logfile_path,'trainsuccess.log') # full log path\n","        successfile = open(logfile_full_path,'w')\n","    \n","        akm_list = []\n","        bestLag_list = []\n","        smape_test_datalength_list = []\n","        skippedcnt_list = []\n","        testsmape_list = []\n","        testr2_list = []\n","        date_range_list = []\n","        at_least_one_col_zero_list = []\n","        at_least_one_col_non_zero_list = []\n","        all_col_zero_list = []\n","        total_records_list = []\n","        total_records_best_lag_df_list = []\n","        best_lag_train_df_records_list = []\n","        isEnoughData_flag_list = []\n","\n","        for index, row in akms2model.iterrows():\n","            print(f'\\n ************************** Iteration {index+1} ************************************ \\n')\n","            AD_GROUP_ID = row['AD_GROUP_ID']\n","            KEYWORD_ID = row['KEYWORD_ID']\n","            MATCH_TYPE = row['MATCH_TYPE']\n","            # THESE NEXT FOUR LINES MUST BE SELECTIVELY UNCOMMENTED\n","            akm = str(AD_GROUP_ID)+'-'+str(KEYWORD_ID)+'-'+MATCH_TYPE\n","            testakm = '157188419817864-177620140515274-PHRASE'\n","            if (akm != testakm):\n","                continue\n","            df = self.getakmdata(fulldf,AD_GROUP_ID,KEYWORD_ID,MATCH_TYPE)\n","            print('hello there')\n","            df.to_csv('./akmtrainingdata.csv')\n","            # if 'ROAS_TARGET' in self.independent_features:\n","            #     df['ROAS_TARGET'] = np.log(((df['SALES_USD']+1)/(df['SPEND_USD']+1)))\n","            df_temp = df.copy()\n","            if ('ROAS_TARGET' in self.independent_features):\n","                df_temp['ROAS_TARGET'] = (df_temp['SALES_USD']+1)/(df_temp['SPEND_USD']+1)\n","            \n","            # create list of all features\n","            features_to_check_data = self.independent_features + [self.target_feature]\n","            # calculate date_range\n","            date_range = (df_temp.REPORT_DATE.max() - df_temp.REPORT_DATE.min()).days + 1                    # to get the number of days\n","            at_least_one_col_zero = len(df_temp.loc[(df_temp[features_to_check_data] == 0).any(axis=1)])     # count of at least on column zero\n","            at_least_one_col_non_zero = len(df_temp.loc[(df_temp[features_to_check_data] != 0).any(axis=1)]) # count of at least on column non zero\n","            all_col_zero = len(df_temp.loc[(df_temp[features_to_check_data] == 0).all(axis=1)])              # count of all column zero\n","            total_records = len(df_temp)                                                                # total records in df\n","\n","            statcols = [self.target_feature]\n","            if (self.isEnoughData(df,statcols)):\n","                pass\n","            else:\n","                print('AKM = ' + akm + ' does not have enough data and is skipped')\n","                count += 1\n","                if (count%100 == 0):\n","                    print(\"done with \" + str(count) + \" out of \" + str(akms2model.shape[0]))\n","                continue\n","            \n","            for feature in features_to_check_data:\n","                if feature == 'ROAS_TARGET':\n","                    df['LNROAS_TARGET'] = np.log(((df['SALES_USD']+1)/(df['SPEND_USD']+1)))\n","    \n","                else:\n","                    df[f'LN{feature}'] = np.log(df[feature]+1)\n","            \n","            try:\n","                features = [f'LN{feature}' for feature in self.independent_features]\n","                target = f'LN{self.target_feature}'\n","                maxlag = self.max_lag\n","                LagToData,LagToFeatures = self.buildLaggedData(akm,df,features,target,maxlag)\n","                objective = 'smape'\n","                bestLagData,bestLag,bestLagFeatures = self.trainModelAndLOOCVTest(akm,LagToData,LagToFeatures,target,objective,successfile)\n","\n","                #train final model and test\n","                testsize = 0.2\n","                knn_output = self.finalKNNModelTrainAndTest(akm,bestLag,bestLagData,bestLagFeatures,target,testsize,successfile)\n","\n","                smape_datalength = knn_output['smapedatalength']\n","                skipped_cnt = knn_output['skippedcnt']\n","                testsmape = knn_output['testsmape']\n","                testr2 = knn_output['testr2']\n","                total_records_best_lag_df = len(bestLagData)\n","                best_lag_train_df_records = int(len(bestLagData)*0.80)\n","                isEnoughData_flag = self.isEnoughData(df,statcols)\n","                \n","                # append akm wise statistics for comparision purpose\n","                akm_list.append(akm)\n","                bestLag_list.append(bestLag)\n","                smape_test_datalength_list.append(smape_datalength)\n","                skippedcnt_list.append(skipped_cnt)\n","                testsmape_list.append(testsmape)\n","                testr2_list.append(testr2)\n","                date_range_list.append(date_range)\n","                at_least_one_col_zero_list.append(at_least_one_col_zero)\n","                at_least_one_col_non_zero_list.append(at_least_one_col_non_zero)\n","                all_col_zero_list.append(all_col_zero)\n","                total_records_list.append(total_records)\n","                total_records_best_lag_df_list.append(total_records_best_lag_df)\n","                best_lag_train_df_records_list.append(best_lag_train_df_records)\n","                isEnoughData_flag_list.append(isEnoughData_flag)\n","\n","                # train final KNN model and seriaize in .pickle format\n","                trained_knn_model = self.finalKNNModel(bestLagData=bestLagData,bestFeatures=bestLagFeatures,target=target)\n","\n","                # serialize final knn model\n","                self.serialize_model(model=trained_knn_model,\n","                                     root_path=model_path,\n","                                     AD_GROUP_ID=AD_GROUP_ID,\n","                                     KEYWORD_ID=KEYWORD_ID,\n","                                     MATCH_TYPE=MATCH_TYPE)\n","                \n","                # serialize metadata json\n","                self.serialize_akm_metadata(df_akm=df,\n","                                            model_root_path=model_path,\n","                                            AD_GROUP_ID=AD_GROUP_ID,\n","                                            KEYWORD_ID=KEYWORD_ID,\n","                                            MATCH_TYPE=MATCH_TYPE,\n","                                            independent_features=self.independent_features,\n","                                            target_feature=self.target_feature,\n","                                            best_lag=bestLag,\n","                                            testsmape=testsmape,\n","                                            testdata_length=smape_datalength,\n","                                            skipped_smape_cnt=skipped_cnt,\n","                                            date_range=date_range, \n","                                            at_least_one_col_zero=at_least_one_col_zero,\n","                                            at_least_one_col_non_zero=at_least_one_col_non_zero,\n","                                            all_col_zero=all_col_zero,\n","                                            total_records=total_records,\n","                                            total_records_best_lag_df=total_records_best_lag_df,\n","                                            best_lag_train_df_records=best_lag_train_df_records, \n","                                            isEnoughData_flag=isEnoughData_flag)\n","                \n","                \n","            except:\n","                print('AKM = '+akm+' training failed ' + str(traceback.format_exc())+'\\n')\n","\n","            count += 1\n","            if (count%100 == 0):\n","                print(\"done with \" + str(count) + \" out of \" + str(akms2model.shape[0]))\n","                print(datetime.now())\n","        \n","        # dataframe of akm statistics for comparision purpose\n","        df_all_metrics = pd.DataFrame({\n","            'akm':akm_list,\n","            'date_range':date_range_list,\n","            'total_records':total_records_list,\n","            'isEnoughData_flag' : isEnoughData_flag_list,\n","            'at_least_one_col_zero':at_least_one_col_zero_list,\n","            'at_least_one_col_non_zero':at_least_one_col_non_zero_list,\n","            'all_col_zero':all_col_zero_list,\n","            'bestLag':bestLag_list,\n","            'best_lag_df_total_records':total_records_best_lag_df_list,\n","            'best_lag_df_train_records' : best_lag_train_df_records_list,\n","            'smape_test_datalength':smape_test_datalength_list,\n","            'smape_skippedcnt':skippedcnt_list,\n","            'testsmape':testsmape_list,\n","            'testr2':testr2_list\n","        })                   \n","        successfile.close()\n","        return df_all_metrics\n","\n","    \n","    def main(self):\n","        df_all_metrics = self.trainModels(input_path=self.input_path,\n","                                          akm_to_model_path=self.akm_to_model_path,\n","                                          logfile_path=self.logfile_path,\n","                                          model_path=self.model_path)\n","\n","        return df_all_metrics"]},{"cell_type":"code","execution_count":4,"metadata":{"executionInfo":{"elapsed":160,"status":"ok","timestamp":1668896369727,"user":{"displayName":"Sukrit Ganesh","userId":"09882607507987906814"},"user_tz":480},"id":"9h216V7NFddU"},"outputs":[],"source":["input_path='trainingdata.csv'\n","akm_to_model_path = 'akm.csv'\n","model_path='KNNModelsDistanceWeighing'\n","logfile_path=model_path\n","max_lag = 15\n","knnweight = 'distance'\n","independent_features=['CPC_USD','SALES_USD','CONVERSIONS','CLICKS','IMPRESSIONS','SPEND_USD','ROAS_TARGET']\n","target_feature = 'CPC_USD'"]},{"cell_type":"code","execution_count":5,"metadata":{"executionInfo":{"elapsed":170,"status":"ok","timestamp":1668896373954,"user":{"displayName":"Sukrit Ganesh","userId":"09882607507987906814"},"user_tz":480},"id":"_tyPZixypLEN"},"outputs":[],"source":["knn_modeling = KnnModelTrain(input_path=input_path,\n","                             akm_to_model_path = akm_to_model_path,\n","                             logfile_path=logfile_path,\n","                             model_path=model_path,\n","                             independent_features=independent_features,\n","                             target_feature = target_feature,\n","                             max_lag=max_lag,\n","                             knnweight=knnweight)"]},{"cell_type":"code","execution_count":6,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":311},"executionInfo":{"elapsed":620,"status":"error","timestamp":1668896376926,"user":{"displayName":"Sukrit Ganesh","userId":"09882607507987906814"},"user_tz":480},"id":"EJSxLB1hmnmd","outputId":"44302b06-49c4-4383-ad83-bb84a8bea1f9"},"outputs":[{"name":"stdout","output_type":"stream","text":["Number of AKMs to model = 1\n","\n"," ************************** Iteration 1 ************************************ \n","\n","hello there\n","AKM\ttarget\tbestSMAPE\tr2\tskippedcnt\tdatalength\tlag = 157188419817864-177620140515274-PHRASE\tLNCPC_USD\t6.12\t0.62\t0\t85\t1\n","AKM\ttarget\ttestSMAPE\tr2\tskippedcnt\tdatalength\tLag = 157188419817864-177620140515274-PHRASE\tLNCPC_USD\t5.37\t-0.2\t0\t20\t1\n"]},{"data":{"image/png":"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","text/plain":["<Figure size 500x500 with 1 Axes>"]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["\n"," ********** KNN model saved at KNNModelsDistanceWeighing/20221123_157188419817864_177620140515274_PHRASE_CPC_USD_KNNModel.pickle **********\n","********** AKM metadata Dictionary saved at KNNModelsDistanceWeighing/20221123_157188419817864_177620140515274_PHRASE_CPC_USD_KNNModel.json ********** \n","\n"]}],"source":["df_all_metrics = knn_modeling.main()"]},{"cell_type":"code","execution_count":7,"metadata":{"id":"ZT8xFxIFwYnR"},"outputs":[{"data":{"text/html":["<div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>akm</th>\n","      <th>date_range</th>\n","      <th>total_records</th>\n","      <th>isEnoughData_flag</th>\n","      <th>at_least_one_col_zero</th>\n","      <th>at_least_one_col_non_zero</th>\n","      <th>all_col_zero</th>\n","      <th>bestLag</th>\n","      <th>best_lag_df_total_records</th>\n","      <th>best_lag_df_train_records</th>\n","      <th>smape_test_datalength</th>\n","      <th>smape_skippedcnt</th>\n","      <th>testsmape</th>\n","      <th>testr2</th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>0</th>\n","      <td>157188419817864-177620140515274-PHRASE</td>\n","      <td>100</td>\n","      <td>100</td>\n","      <td>True</td>\n","      <td>50</td>\n","      <td>100</td>\n","      <td>0</td>\n","      <td>1</td>\n","      <td>99</td>\n","      <td>79</td>\n","      <td>20</td>\n","      <td>0</td>\n","      <td>5.37</td>\n","      <td>-0.2</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>"],"text/plain":["                                      akm  date_range  total_records  \\\n","0  157188419817864-177620140515274-PHRASE         100            100   \n","\n","   isEnoughData_flag  at_least_one_col_zero  at_least_one_col_non_zero  \\\n","0               True                     50                        100   \n","\n","   all_col_zero  bestLag  best_lag_df_total_records  \\\n","0             0        1                         99   \n","\n","   best_lag_df_train_records  smape_test_datalength  smape_skippedcnt  \\\n","0                         79                     20                 0   \n","\n","   testsmape  testr2  \n","0       5.37    -0.2  "]},"execution_count":7,"metadata":{},"output_type":"execute_result"}],"source":["df_all_metrics"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":[]}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3.10.8 ('konferenv')","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.10.8"},"vscode":{"interpreter":{"hash":"7460d441b5a2df99d051490e5490331ce03b335220e9c7f658719b37819ef91b"}}},"nbformat":4,"nbformat_minor":0}
